---
title: "Vignette_2_NHANES_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette_2_NHANES_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
library(mvnimpute) # for imputation
```

We select a subset of the NHANES 2011 - 2016 dataset in the `mvnimpute` package. WE take the PCB measurements data to show the necessary steps for doing multiple imputation using the `mvnimpute` package.

```{r}
# select subset of the NHANES data: PCB
analysis.data <- as.matrix(dplyr::select(nhanes.dat$data, starts_with("LBC") & !ends_with("LA")))                      
censoring.ind <- as.matrix(dplyr::select(nhanes.dat$data, starts_with("LBD")))
LLODs <- as.matrix(nhanes.dat$PCB.LOD)   # lower limits of detection (LLODs)
year <- nhanes.dat$data$SDDSRVYR         # survey year indicator

# rename columns to respective PCB names
colnames(analysis.data) <- colnames(censoring.ind) <- paste0("PCB", substr(colnames(analysis.data), 4, 6))

# remove item nonresponse
item.nonresponse <- numeric()
count <- 0
for (i in 1:nrow(analysis.data)) {
  if (sum(is.na(analysis.data[i, ])) == ncol(analysis.data)) {
    count <- count + 1
    item.nonresponse[count] <- i
  }
}

year <- year[-item.nonresponse]
analysis.data <- analysis.data[-item.nonresponse, ]
censoring.ind <- censoring.ind[-item.nonresponse, ]
```

The tables below show some summary statistics of the data we just obtained: 

```{r}
# dimension of the analysis data
analysis.dim <- dim(analysis.data)
analysis.dim
summary(analysis.data)
```

From the above table, we see that the data has `r analysis.dim[1]` subjects with `r analysis.dim[2]` variables, almost every variable has a few missing values.

```{r}
# censoring indicator matrix
table(year)
LLODs
head(censoring.ind)
```

The first two tables show the survey years and the lower limits of detection (LLODs) information for each variable. The values as shown in LLODs are the original LLODs divied by $\sqrt{2}$. The third table above show the censoring indicator matrix for those PCB measurements data, the values correspond to the values from the original NHANES dataset, where 0 indicates observed values, 1 indicates censored values, and `NA` indicates missing values (not shown here). In order to use our package, we have to re-code the data type indicators as follows:

* 0: missing values
* 1: observed values
* 2: censoring values

```{r}
### re-code the censoring indicator matrix
for (i in 1:nrow(censoring.ind)) {
  for (j in 1:ncol(censoring.ind)) {
    # censored value
    censoring.ind[i, j] <- ifelse(censoring.ind[i, j] == 1, 2, censoring.ind[i, j])
    # observed value
    censoring.ind[i, j] <- ifelse(censoring.ind[i, j] == 0, 1, censoring.ind[i, j])
  }
}

for (i in 1:nrow(censoring.ind)) {
  censoring.ind[i, which(is.na(censoring.ind[i, ]))] <- 0
}
# display the first few lines
head(censoring.ind)
```

Next, we have to create a list object for including the censoring bounds information for each of the data point. Specifically, we take missing data as a special type of "censoring" data with two censoring limits corresponding to $-\infty$ and $\infty$, respectively. In this package, we take $-10,000$ and $10,000$ as proxies for $-\infty$ and $\infty$, respectively. We create a list including two matrices, which contain the lower bounds and upper bounds respectively, as follow,

* For missing values, the corresponding entries in the first matrix are $-10,000$, the corresponding entries in the second matrix are $10,000$
* For observe values, the corresponding entries in the first matrix are the observed quantities, the corresponding entries in the second matrix are equal to those in the first matrix
* For the censored values, the corresponding entries in the first matrix are $-10,000$, the corresponding entries in the second matrix are the corresponding lower limits of detection (LLODs). Note that the measurements fall below LLODs can be viewed as left censored values with the LLODs as the upper censoring limits.

```{r}
# create bounds
bounds <- list()

bounds1 <- bounds2 <- matrix(0, nrow = nrow(analysis.data), ncol = ncol(analysis.data))
## log transformation
for (i in 1:nrow(bounds1)) {
  for (j in 1:ncol(bounds1)) {
    if (censoring.ind[i, j] == 1) {
      bounds1[i, j] <- bounds2[i, j] <- log(analysis.data[i, j])
    }
    else if (censoring.ind[i, j] == 0) {
      bounds1[i, j] <- -10000
      bounds2[i, j] <- 10000
    }
    else {
      bounds1[i, j] <- -10000
      bounds2[i, j] <- log(analysis.data[i, j] * sqrt(2)) # censored values are LLODs/sqrt(2)
    }
  }
}
bounds[[1]] <- bounds1; bounds[[2]] <- bounds2
colnames(bounds[[1]]) <- colnames(bounds[[2]]) <- colnames(analysis.data)
head(bounds[[1]][, 1:5]); head(bounds[[2]][, 1:5])
```

The tables show the tow matrices, we note that the PCB028 and PCB066 values for the six row are censored since only the lower limit is infinity, as represented by -10,000. In creating the list, we log-transformed the data to better approach normality, which is th assumption that our package based on, and since the laboratory measurements data can only take positive values. We will transform the imputed dataset back to the original scale after imputation.

# Multiple imputation

```{r, messsage = FALSE}
####
p <- ncol(analysis.data)
#### MI
### prior specification
prior.spec <- list(
  mu.0 = rep(0, p),
  Lambda.0 = diag(10, p),
  kappa.0 =  100,
  nu.0 = p * (p + 1) / 2
)

start.vals <- list(
  mu = rep(1, p),
  sigma = diag(p)
)

iter <- 1000
sim.dat <- multiple.imputation(
  bounds,
  prior.spec,
  start.vals,
  iter,
  FALSE
)
```

# Markov chain diagnostic plots

```{r, fig.align = "center", fig.width = 6, fig.height = 6}
# mean convergence plot
conv.plot(sim.dat$simulated.mu, iter, title = "mean convergence plot: all PCB")
conv.plot(sim.dat$simulated.sig, iter, title = "mean convergence plot: all PCB")
```

The convergence plots show that the algorithm converge very fast. We compare the marginal distribution of the data between the imputed dataset from the last iteration and the original dataset.

```{r}
## compare the marginal density plots of the original data and the imputed data (last iteration)
imputed.data <- sim.dat$imputed[[iter]]
imputed.data.ori <- exp(imputed.data)

for (i in 1:ncol(analysis.data)) {
  plot(density(na.omit(analysis.data[, i])), main = paste0("PCB", substr(colnames(analysis.data)[i], 4, 6)))
  lines(density(imputed.data.ori[, i]), col = 2, lty = 2)
}
table(censoring.ind[, "PCB189"])
```

The plots indicate that the imputed data align well with the original data, for variables with many censored values, such as PCB189, the peak which indicates a concentration of LLODs, is expected to be shifted a little bit to the left, since we are imputing values smaller than the censoring values.


