---
title: "simulated_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulated_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{clusterGeneration}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(123)
```

```{r setup}
library(mvnimpute)
```

## Simulated data generation

```{r}
n <- 2000; p <- 10
miss.num <- 4; censor.num <- 4
m.vec <- rnorm(p, 5, 1)
V <- clusterGeneration::genPositiveDefMat("eigen", dim = p)

sim.dat <- dat.gen(n, m.vec, V$Sigma, p, miss.num, censor.num)

# CC and AC parameters

params <- calcu.param(sim.dat$comp.dat)

summary(sim.dat$comp.dat)
```

We generate a 10-dimensional dataset with 4 subject to missing and 4 to censoring, with 2000 sample size. Mean vector is randomly selected from a normal distribution with mean 5 and standard deviation 1, the covariance matrix is generated by *genPositiveDefMat* function from **clusterGeneration** package. Column names of the incomplete dataset include the type of the variable, whether it is missing, censored or fully observed. Next, we will use *marg.plot* function to examine the marginal distribution plot of each variable in the incomplete dataset. We see that marginally, each variable nearly follow a normal distribution as expected.

```{r}
marg.plot(sim.dat$comp.dat, title = colnames(sim.dat$comp.dat))
```

Before running multiple imputation, we have to fill in the missing and censored values to make the incomplete data complete.

```{r, message = FALSE}
fill.dat <- initial.impute(sim.dat$comp.dat,
                           sim.dat$miss.indx,
                           sim.dat$miss.pos,
                           sim.dat$censor.indx,
                           sim.dat$censor.pos)
```

Then, we need to specify the number of iterations we would like to run for the multiple imputation, the prior parameters for the Normal-inverse-Wishart conjugate prior distribution, and initial values for the parameters.

```{r, message = FALSE}
iter <- 1000

prior.param <- list(
  params$AC.mean,
  params$AC.var,
  100,
  p * (p + 1) / 2
)

ini.vals <- list(
  params$CC.mean,
  params$CC.cov
)

censor.val <- list(sim.dat$C1,
                   sim.dat$C2)

simulation <- multiple.impute(
  1000,
  prior.param,
  ini.vals,
  fill.dat,
  sim.dat$miss.indx,
  sim.dat$miss.pos,
  sim.dat$censor.indx,
  sim.dat$censor.pos,
  censor.val,
  "interval"
)
```

After multiple imputation, we will draw marginal density plots of the original data and the imputed dataset from the last iteration. We see that the marginal densities of the original data and the imputed data align quite well to each other.

```{r}
for (i in 1:ncol(sim.dat$comp.dat)) {
  plot(density(na.omit(sim.dat$comp.dat[, i])), main = colnames(sim.dat))
  lines(density(simulation$imputed.dat[[iter]][, i]), col = 2, lty = 2)
}
```

## Diagnostic plots 

The vertical axes of the convergence plots and the averaged simulated values plots

```{r}
conv.plot(simulation$simulated.mu, iter)
conv.plot(simulation$simulated.sig, iter)
```

```{r}
avg.plot(simulation$simulated.mu, iter)
avg.plot(simulation$simulated.sig, iter)
```

The autocorrelation plots indicate that the autoccorrelations decay very fast. So we pool the simulated values from 80\% of the iterations to the end of simulation with 10\% of iterations as intervals.

```{r}
calcu.acf(simulation$simulated.mu, lag = 100, title = paste(colnames(simulation$simulated.mu), "mean"))
calcu.acf(simulation$simulated.sig, lag = 100, title = paste(colnames(simulation$simulated.sig), "variance"))
```

## Comparison tables

Below the tables summarize the biased of the full data mean and variance, complete-case mean and variance, simulated mean and variance from the Gibbs sample from the truly specified mean and variance. We observe that the biases of the full data means and the simulated means are quite comparable except a few marginal variables. The censored values are more prone to larger biases.

```{r, echo = FALSE}
full.dat.mean <- apply(sim.dat$full.dat, 2, mean)
CC.mean <- params$CC.mean

Gibbs <- seq(0.8 * iter, iter, by = 0.1 * iter)
simulate.mean <- apply(simulation$simulated.mu[Gibbs, ], 2, mean)

compare.mean <- data.frame(rbind(full.dat.mean, CC.mean, simulate.mean, m.vec))
rownames(compare.mean) <- c("full.mean", "CC.mean", "simulated.mean","true.mean")
bias.mean <- sweep(compare.mean, 2, m.vec)

full.dat.var <- apply(sim.dat$full.dat, 2, var)
CC.var <- params$CC.var

simulate.var <- apply(simulation$simulated.sig[Gibbs, ], 2, mean)

compare.var <- data.frame(rbind(full.dat.var, CC.var, simulate.var, diag(V$Sigma)))
rownames(compare.var) <- c("full.variance", "CC.variance", "simulated.variance","true.variance")
bias.variance <- sweep(compare.var, 2, diag(V$Sigma))
```

```{r, echo = FALSE}
####
bias.mean
```

```{r, echo = FALSE}
####
bias.variance
```
