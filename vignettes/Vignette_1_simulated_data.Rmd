---
title: "Vignette_1_simulated_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette_1_simulated_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
old <- options(scipen = 999)
set.seed(115)
```

```{r setup}
library(mvnimpute)
```

This tutorial describes how to use the **mvnimpute** package. We will go through an example generated by the `data.generation` function in the package.

## Data generation

```{r}
#### data generation
n <- 500; p <- 6
# set.seed(133)
m <- c(1, 1, 2, 4, 3, 5)
v <- clusterGeneration::genPositiveDefMat(p, "eigen")$Sigma

miss.var <- c(1, 2)
censor.var <- c(3, 5)

example.data <- data.generation(num_ind = n,
                                mean_vec = m,
                                cov_mat = v,
                                miss_var = miss.var,
                                miss_mech = "MAR",
                                miss_prob = NULL,
                                censor_var = censor.var,
                                censor_type = "interval",
                                censor_param = 0.5)

names(example.data)
```

We generate a dataset with sample size `r n`, with specified mean vector consists of six specified values, and a random positive definite covariance matrix. The output includes four objects which include, `full.data`, the data matrix that would have been observed without missing and censoring information; `observe.data`, the truly observed data matrix with missing and censoring information; `bounds`, the bounds information of the variables that have missing or censored values. Specifically, we take missing as a special type of interval censoring with no censoring limits (censoring limits are set as $\pm \infty$); `indicator`, the matrix that indicating the data type: 0 as the missing data, 1 as the observed data, and 2 as the censored data. Now, let us take a look at the dataset

```{r}
# data
full <- example.data$full.data
observed <- example.data$observe.data
censoring.bounds <- example.data$bounds
indicator <- example.data$indicator
# summary
tail(observed) # observed data
tail(censoring.bounds[[1]]);tail(censoring.bounds[[2]]) # censoring bounds information
tail(indicator) # indicator matrix
```

From the observed data matrix, the missing values are denoted as `NA`, the censored values are denoted as `NaN`. The missing data has censoring limits set as $\pm 10,000$ (we set $\pm 10,000$ as proxies for $\pm \infty$). The indicator matrix labels the missing value as 0 and the interval censored value as 4. Then the plot that visually shows the percentages of observed, missing and censored values can be generated by the `visual.plot` function.

```{r, message = FALSE, fig.align = "center", fig.height = 5, fig.width = 8}
visual.plot(indicator, title = NULL)
```

## Multiple Imputation

For doing multiple imputation, we take a Normal-Inverse-Wishart distribution for joint prior distribution of the mean vector and covariance matrix. We run MCMC simulation for 1,000 iterations.

```{r, message = FALSE}
### prior specifications
prior.spec <- list(
  mu.0 = rep(0, p),
  Lambda.0 = diag(10, p),
  kappa.0 = 100,
  nu.0 = p * (p + 1) / 2
)

start.vals <- list(
  mu = rep(1, p),
  sigma = diag(p)
)
### MCMC simulation
iter <- 1000
sim.res <- multiple.imputation(
  censoring.bounds,
  prior.spec,
  start.vals,
  iter,
  TRUE
)
```

### Convergence plots

```{r, fig.align = "center", fig.height = 5, fig.width = 5}
conv.plot(sim.res$simulated.mu, 0, iter, title = "convergence plot of the mean values")
conv.plot(sim.res$simulated.sig, 0, iter, title = "convergence plot of the variance values")
```

### Autocorrelation plots

```{r}
title = paste("acf: variable", 1:p)
acf.calc(sim.res$simulated.mu, title = title)
acf.calc(sim.res$simulated.sig, title = title)
```

From the convergence plots and the autocorrelation plots, we see that the posterior distributions of both the mean and variance seem to converge to equilibrium in first few iterations. 

### Marginal plot

We draw and compare the marginal density plots using the full data, the CC data and the imputed data from the last iteration of MCMC using the **mvnimpute** package.

```{r}
for (i in c(1, 2, 3, 5)) {
  plot(density(full[, i]), main = colnames(full)[i])
  lines(density(observed[!is.na(observed[, i]), i]), col = 6, lty = 2)
  lines(density(sim.res$imputed.data[[iter]][, i]), col = 4, lty = 3)
}
```

The black line is the density plot of the full data, the blue dotted line is the imputed data using the **mvnimpute** pacakge, the pink dashed line is the CC data. We see that the imputed data density align with the full data density quite well.

### Linear Regression

```{r, echo = FALSE}
##############################################
swp.true <- function(
  aug.mat, # augmented covariance matrix
  # NOTE: swp = 0 is to sweep the first row
  outcome, # outcome variable
  swp.indx # index of variables
) {

  aug.mat.dim <- dim(aug.mat)
  rows <- aug.mat.dim[1]
  cols <- aug.mat.dim[2]

  # initiate SWEEP Operator
  swp.mat <- aug.mat
  # create a matrix to store the values after SWEEP Operator
  # this matrix will iterate in the loop

  h.jj <- NA # the diagonal element
  h.ij <- numeric(rows - 1) # the margin vectors
  mat.jk <- matrix(NA, nrow = (rows - 1), ncol = (cols - 1)) # the SS-CP matrix

  swp.ind <- swp.indx[swp.indx != outcome]

  for (i in swp.ind) {

    h.jj <- -1 / swp.mat[(i + 1), (i + 1)]
    h.ij <- swp.mat[(i + 1),-(i + 1)] / swp.mat[(i + 1), (i + 1)]
    mat.jk <- swp.mat[-(i + 1), -(i + 1)] - swp.mat[(i + 1),-(i + 1)] %*% t(swp.mat[(i + 1),-(i + 1)]) / swp.mat[(i + 1), (i + 1)]

    swp.mat[i + 1, i + 1] <- h.jj # the swept element
    swp.mat[i + 1, -(i + 1)] <- swp.mat[-(i + 1), i + 1] <- h.ij # the swept row and column
    swp.mat[-(i + 1), - (i+ 1)] <- mat.jk

  }
  return(swp.mat)
}

# true regression parameters
## construct the augmented covariance matrix
aug.cov <- rbind(c(-1, m), cbind(m, v))
colnames(aug.cov) <- rownames(aug.cov) <- NULL
out.var <- 4
true.beta <- swp.true(aug.cov, out.var, 1:p)[, out.var + 1][-(out.var + 1)]
```

```{r}
full.reg <- coef(lm(y4 ~ y1 + y2 + y3 + y5 + y6, data = data.frame(full)))
cc.reg <- coef(lm(y4 ~ y1 + y2 + y3 + y5 + y6, data = data.frame(observed)))

### imputed data
gibbs <- seq(800, 1000, 50)

#### mvnimpute
mvnimpute.dat <- list()
model.param <- list()
for (i in 1:length(gibbs)) {
  
  mvnimpute.dat[[i]] <- sim.res$imputed.data[[gibbs[i]]]
  colnames(mvnimpute.dat[[i]]) <- paste0("y", 1:p)
  model.param[[i]] <- lm(y4 ~ y1 + y2 + y3 + y5 + y6, data.frame(mvnimpute.dat[[i]]))
  
}

mvnimpute.mod <- summary(mice::pool(model.param))
sim.reg <- mvnimpute.mod[, 2]

reg.compare <- data.frame(
  true = true.beta,
  full = full.reg,
  mvnimpute = sim.reg,
  cc = cc.reg
)
reg.compare

options(old)
```
